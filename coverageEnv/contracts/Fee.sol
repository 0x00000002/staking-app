pragma solidity ^0.4.18;


import './SafeMath.sol';
import './Owned.sol';
import './Validating.sol';
import './StandardToken.sol';


/**
  * @title FEE is an ERC20 token used to pay for trading on the exchange.
  * For deeper rational read https://leverj.io/whitepaper.pdf.
  * FEE tokens do not have limit. A new token can be generated by owner.
  */
contract Fee is Owned, Validating, StandardToken {event __CoverageFee(string fileName, uint256 lineNumber);
event __FunctionCoverageFee(string fileName, uint256 fnId);
event __StatementCoverageFee(string fileName, uint256 statementId);
event __BranchCoverageFee(string fileName, uint256 branchId, uint256 locationIdx);
event __AssertPreCoverageFee(string fileName, uint256 branchId);
event __AssertPostCoverageFee(string fileName, uint256 branchId);


  /* This notifies clients about the amount burnt */
  event Burn(address indexed from, uint256 value);

  string public name;                   //fancy name: eg Simon Bucks
  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
  string public symbol;                 //An identifier: eg SBX
  uint256 public feeInCirculation;      //total fee in circulation
  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.
  address public minter;

  modifier onlyMinter {__FunctionCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',1);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',28);
    __AssertPreCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',1);
 __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',1);
require(msg.sender == minter);__AssertPostCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',1);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',29);
    _;
  }

  /// @notice Constructor to set the owner, tokenName, decimals and symbol
  function Fee(
  address[] _owners,
  string _tokenName,
  uint8 _decimalUnits,
  string _tokenSymbol
  )
  public
  notEmpty(_tokenName)
  notEmpty(_tokenSymbol)
  {__FunctionCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',2);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',43);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',2);
setOwners(_owners);
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',44);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',3);
name = _tokenName;
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',45);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',4);
decimals = _decimalUnits;
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',46);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',5);
symbol = _tokenSymbol;
  }

  /// @notice To set a new minter address
  /// @param _minter The address of the minter
  function setMinter(address _minter) external onlyOwner validAddress(_minter) {__FunctionCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',3);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',52);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',6);
minter = _minter;
  }

  /// @notice To eliminate tokens and adjust the price of the FEE tokens
  /// @param _value Amount of tokens to delete
  function burnTokens(uint _value) public notZero(_value) {__FunctionCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',4);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',58);
    __AssertPreCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',2);
 __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',7);
require(balances[msg.sender] >= _value);__AssertPostCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',2);


__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',60);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',8);
balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',61);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',9);
feeInCirculation = SafeMath.sub(feeInCirculation, _value);
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',62);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',10);
Burn(msg.sender, _value);
  }

  /// @notice To send tokens to another user. New FEE tokens are generated when
  /// doing this process by the minter
  /// @param _to The receiver of the tokens
  /// @param _value The amount o
  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {__FunctionCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',5);

__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',70);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',11);
balances[_to] = SafeMath.add(balances[_to], _value);
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',71);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',12);
feeInCirculation = SafeMath.add(feeInCirculation, _value);
__CoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',72);
     __StatementCoverageFee('/Users/tikonoff/projects/staking-master/contracts/Fee.sol',13);
Transfer(msg.sender, _to, _value);
  }
}
